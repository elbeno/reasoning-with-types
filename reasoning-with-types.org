#+TITLE:     Reasoning with Types
#+AUTHOR:    Ben Deane
#+EMAIL:     bdeane@blizzard.com
#+DATE:      Sometime 2015
#+DESCRIPTION: Using types to reason about interfaces and code
#+KEYWORDS: types
#+LANGUAGE:  en
#+OPTIONS:   H:1 num:t toc:nil \n:nil @:t ::t |:t ^:nil -:t f:t *:t <:t
#+OPTIONS:   TeX:t LaTeX:t skip:nil d:nil todo:t pri:nil tags:not-in-toc
#+INFOJS_OPT: view:nil toc:nil ltoc:t mouse:underline buttons:0 path:http://orgmode.org/org-info.js
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport
#+LINK_UP:
#+LINK_HOME:
#+XSLT:
#+LaTeX_CLASS: beamer
#+COLUMNS: %40ITEM %10BEAMER_env(Env) %9BEAMER_envargs(Env Args) %4BEAMER_col(Col) %10BEAMER_extra(Extra)
#+LaTeX_HEADER: \usepackage{helvet}
#+LaTeX_HEADER: \usepackage{amsmath, amsthm, amssymb, breqn}
#+BEAMER_THEME: Madrid
#+BEAMER_COLOR_THEME: wolverine
#+STARTUP: beamer

# To generate notes pages only:
# +LaTeX_CLASS_OPTIONS: [handout]
# +LaTeX_HEADER: \setbeameroption{show only notes}
# +LaTeX_HEADER: \usepackage{pgfpages}
# +LaTeX_HEADER: \pgfpagesuselayout{2 on 1}[letterpaper,portrait,border shrink=5mm]

# For normal presentation output:
#+LaTeX_CLASS_OPTIONS: [bigger]
#+LaTeX_HEADER: \setbeamertemplate{navigation symbols}{}%remove navigation symbols

* What is a type?
What do you think?

* Let's play a game
To help us get thinking about types.

I'll tell you a type.

You tell me how many values it has.

* Level 1
** How many values?
#+begin_src c++
bool;
#+end_src

* Level 1
** How many values?
#+begin_src c++
char;
#+end_src

* Level 1
** How many values?
#+begin_src c++
void;
#+end_src

* Level 1
** How many values?
#+begin_src c++
struct Foo
{
};
#+end_src

* Level 1
** How many values?
#+begin_src c++
enum Foo
{
  BAR,
  BAZ,
  QUUX
};
#+end_src

* Level 1
** How many values?
#+begin_src c++
template <class T>
struct Foo
{
  T m_t;
};
#+end_src

* End of Level 1
- Algebraically, a type is the number of values that inhabit it.
** These types are equivalent
#+begin_src c++
bool;

enum Foo
{
  BAR,
  BAZ
};
#+end_src
** a block                                                 :B_ignoreheading:
:PROPERTIES:
:BEAMER_env: ignoreheading
:END:
- Let's move on to level 2.

* Level 2
** How many values?
#+begin_src c++
pair<char, bool>;
#+end_src

* Level 2
** How many values?
#+begin_src c++
struct Foo
{
  char a;
  bool b;
};
#+end_src

* Level 2
** How many values?
#+begin_src c++
tuple<bool, bool, bool>;
#+end_src

* Level 2
** How many values?
#+begin_src c++
template <class T, class U>
struct Foo
{
  T m_t;
  U m_u;
};
#+end_src

* End of Level 2
- When two types are "concatenated" into one compound type, we _multiply_ the # of
  inhabitants of the components.
- This kind of compounding gives us a _product type_.
- On to Level 3.

* Level 3
** How many values?
#+begin_src c++
optional<char>;
#+end_src

* Level 3
** How many values?
#+begin_src c++
variant<char, bool>;
#+end_src

* Level 3
** How many values?
#+begin_src c++
template <class T, class U>
struct Foo
{
  variant<T,U> m_v;
};
#+end_src

* End of Level 3
- When two types are "alternated" into one compound type, we _add_ the # of
  inhabitants of the components.
- This kind of compounding gives us a _sum type_.
- Caution: Miniboss detected ahead.

* Level 4
** How many values?
#+begin_src c++
template <class T>
struct Foo
{
  variant<T,T> m_v;
};
#+end_src

* Level 4
** How many values?
#+begin_src c++
template <class T>
struct Foo
{
  bool b;
  T m_t;
};
#+end_src

* Level 4
** How many values?
#+begin_src c++
bool f(bool);
#+end_src

* Level 4
** Four possible values
#+begin_src c++
bool f1(bool) { return true; }
bool f2(bool) { return false; }
bool f3(bool b) { return b; }
bool f4(bool b) { return !b; }
#+end_src

* Miniboss: Algebraic Conundrum "Function"
** How many values?
#+begin_src c++
char f(bool);
#+end_src

* Miniboss: Algebraic Conundrum "Function"
** How many values (for \texttt{f})?
#+begin_src c++
enum Foo
{
  BAR,
  BAZ,
  QUUX
};
char f(Foo);
#+end_src

* Miniboss: Algebraic Conundrum "Function"
** How many values?
#+begin_src c++
template <class T, class U>
U f(T);
#+end_src

* Victory!
- The type of a _function_ from \(\mathnormal{A}\) to \(\mathnormal{B}\) has \(\mathnormal{B^A}\) possible values.
- Hence a curried function is equivalent to its uncurried alternative:

** block                                                   :B_ignoreheading:
:PROPERTIES:
:BEAMER_env: ignoreheading
:END:
#+BEGIN_LaTeX
\begin{align*}
\mathnormal{F_{uncurried}::(A,B) \rightarrow C} & \mathnormal{\Leftrightarrow C^{A*B}} \\
& \mathnormal{= C^{B*A}} \\
& \mathnormal{= (C^B)^A} \\
& \mathnormal{\Leftrightarrow (B \rightarrow C)^A} \\
& \mathnormal{\Leftrightarrow F_{curried}::A \rightarrow (B \rightarrow C)}
\end{align*}
#+END_LaTeX
- WARNING: Boss detected ahead!

* Boss: Algebraic Enigma "Data Structure"
** How many values?
#+begin_src c++
template <typename T>
class vector<T>;
#+end_src

* Boss: Algebraic Enigma "Data Structure"
We can define a \texttt{vector<T>} recursively:

** block                                                   :B_ignoreheading:
:PROPERTIES:
:BEAMER_env: ignoreheading
:END:
#+BEGIN_LaTeX
\begin{align*}
\mathnormal{v(t) =} & \mathnormal{1 + t v(t)}
\end{align*}
#+END_LaTeX

** block                                                   :B_ignoreheading:
:PROPERTIES:
:BEAMER_env: ignoreheading
:END:
And rearrange...

** block                                                   :B_ignoreheading:
:PROPERTIES:
:BEAMER_env: ignoreheading
:END:
#+BEGIN_LaTeX
\begin{align*}
\mathnormal{v(t) - t v(t) =} & \mathnormal{1} \\
\mathnormal{v(t) (1-t) =} & \mathnormal{1} \\
\mathnormal{v(t) =} & \mathnormal{\frac{1}{1-t}}
\end{align*}
#+END_LaTeX

* Boss: Algebraic Enigma "Data Structure"
** block                                                   :B_ignoreheading:
:PROPERTIES:
:BEAMER_env: ignoreheading
:END:
#+BEGIN_LaTeX
\begin{align*}
\mathnormal{v(t) =} & \mathnormal{\frac{1}{1-t}}
\end{align*}
#+END_LaTeX

** block                                                   :B_ignoreheading:
:PROPERTIES:
:BEAMER_env: ignoreheading
:END:
What does it mean? Let's [[http://www.wolframalpha.com/input/?i=1%2F%281-t%29][\color{blue}ask Wolfram Alpha]].

* Boss: Algebraic Enigma "Data Structure"
A \texttt{vector<T>} can have:
- 0 elements (\(\mathnormal{1}\))
- 1 element (\(\mathnormal{t}\))
- 2 elements (\(\mathnormal{t^2}\))
- etc...

* Boss: Algebraic Enigma "Data Structure"
** How many values?
#+BEGIN_LaTeX
\begin{align*}
\texttt{vector<T>} &
\mathnormal{\Leftrightarrow 1 + t + t^2 + t^3 + ...} \\
& \mathnormal{= \frac{1}{1-t}}
\end{align*}
#+END_LaTeX

* Victory!
Reasoning about types in an algebraic way allows us to discover equivalent
formulations for APIs, Data Structures, etc which may be more natural or more efficient.
\\[2\baselineskip]
It also helps us prevent errors by making illegal states unrepresentable.

* Let's play another game
I'll give you a mystery function type.

You tell me possible ways to write and name the function.

There's one rule: I insist on _total_ functions.

* What's That Function?
** Name/Implement \texttt{f}
#+begin_src c++
template <class T>
T f(T);
#+end_src

* What's That Function?
** Name/Implement \texttt{f}
#+begin_src c++
template <class T, class U>
T f(pair<T,U>);
#+end_src

* What's That Function?
** Name/Implement \texttt{f}
#+begin_src c++
template <class T>
T f(bool, T, T);
#+end_src

* What's That Function?
** Name/Implement \texttt{f}
#+begin_src c++
template <class T, class U>
U f(function<U(T)>, T);
#+end_src

* What's That Function?
** Name/Implement \texttt{f}
#+begin_src c++
template <class T>
vector<T> f(vector<T>);
#+end_src

* What's That Function?
** Name/Implement \texttt{f}
#+begin_src c++
template <class T>
T f(vector<T>);
#+end_src

* What's That Function?
** Name/Implement \texttt{f}
#+begin_src c++
template <class T>
optional<T> f(vector<T>);
#+end_src

* What's That Function?
** Name/Implement \texttt{f}
#+begin_src c++
template <class T, class U>
vector<U> f(function <U(T)>, vector<T>);
#+end_src

* What's That Function?
** Name/Implement \texttt{f}
#+begin_src c++
template <class T>
T f(optional<T>);
#+end_src

* What's That Function?
** Name/Implement \texttt{f}
#+begin_src c++
template <class K, class V>
V f(map<K,V>, K);
#+end_src

* What's That Function?
** Name/Implement \texttt{f}
#+begin_src c++
template <class K, class V>
optional<V> f(map<K,V>, K);
#+end_src

* Victory!
Type signatures can tell us a lot about functionality. Using the type system
appropriately and writing _total functions_ makes interfaces safer to use.

* The rabbit hole goes deeper
- [[http://en.wikipedia.org/wiki/Algebraic_data_type][\color{blue}Algebraic data type (Wikipedia)]]
- [[http://chris-taylor.github.io/blog/2013/02/10/the-algebra-of-algebraic-data-types/][\color{blue}The Algebra of Algebraic Data Types (blog)]]
- [[http://https://www.youtube.com/watch?v=YScIPA8RbVE][\color{blue}The Algebra of Algebraic Data Types (video)]]

Let's hope C++ gets sum types (variant) in the standard soon...

* Goals for well-typed interfaces
- Achieve formulations that:
  - are more natural
  - perform better
- Write total functions
- Make illegal states unrepresentable

\begin{center}
Reasoning with types helps with all of this - try it!
\end{center}
